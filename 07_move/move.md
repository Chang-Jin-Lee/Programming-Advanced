# C++ Copy / Move Semantics 정리

## 1) 복사(Copy) 기본

* **복사 생성자**: `T(const T&)`
* **복사 대입 연산자**: `T& operator=(const T&)`
* **호출되는 때**

  1. 선언+초기화: `T a(b);`
  2. 값 전달 인자: `void f(T a)`
  3. 값 반환: `T f() { return T{}; }`

> 별도 정의가 없으면 **디폴트 복사**(얕은 복사)가 자동 생성됩니다.

## 2) 깊은 복사(Deep Copy)가 필요한 경우

* 리소스(동적 메모리, 파일 핸들 등)를 **소유**하는 클래스는

  * **복사 시 독립적인 소유**가 되어야 함
  * 이중 해제, 댕글링 포인터, 공유로 인한 부작용 방지
* \=> 직접 **복사 생성자/복사 대입** 구현

## 3) 이동(Move) 기본

* **이동 생성자**: `T(T&&) noexcept`
* **이동 대입**: `T& operator=(T&&) noexcept`
* **의미**: 리소스의 **소유권만 이전**(얕은 복사 + 원본 무효화)
* **호출되는 때**

  1. rvalue(임시 객체) 전달
  2. `std::move(x)`로 **lvalue를 rvalue로 캐스팅**한 경우

> `std::move` 는 **이동을 실행하지 않습니다**. 단지 rvalue로 **캐스팅**하여, rvalue 오버로드가 선택되도록 만듭니다.

## 4) Rule of Three / Five / Zero

* **Three**: 소멸자, 복사 생성자, 복사 대입
* **Five**: (Three) + 이동 생성자, 이동 대입
* **Zero**: 소유 리소스를 직접 관리하지 않으면(=모두 값/스마트포인터) 사용자 정의 없이 기본이 좋음

## 5) 컨테이너와 `noexcept`

* `std::vector` 등은 **이동 생성자가 `noexcept` 일 때만** 재할당 시 이동을 선호합니다.
  → 성능을 위해 \*\*이동 생성자/대입에 `noexcept`\*\*를 붙이세요.

## 6) `const`와 이동

* `const T` 는 **이동 불가**(상태를 바꿀 수 없기 때문).
* `const T&&` 로 받으면 보통 **복사**가 선택됩니다. (이동 의도에 맞지 않음)

## 7) 자주 나오는 실수

* 리소스 소유 클래스에 복사만 구현하고 소멸자를 빼먹음 → 누수/중복해제
* `std::move` 남용 → 이후 쓰지 않을 객체에만 사용
* 이동 생성자에 `noexcept` 누락 → 컨테이너가 복사로 폴백

## 8) 시험 포인트

1. 복사/이동 생성자 호출 시점 나열하기
2. 깊은 복사 vs 얕은 복사 비교 및 필요 이유
3. `std::move` 의 실제 역할 설명
4. `const` 객체에 `std::move` 를 적용하면 왜 이동이 안 되는지
5. `noexcept` 가 컨테이너 이동 선택에 미치는 영향
6. Rule of Three/Five/Zero 개념과 적용 상황

---